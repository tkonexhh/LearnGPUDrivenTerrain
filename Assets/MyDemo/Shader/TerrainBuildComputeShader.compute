// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TraverseQuadTree
#pragma kernel BuildPatches

#pragma multi_compile_local __ BOUNDS_DEBUG //开启Patch BOUNDS 调式

#include "./TerrainInput.hlsl"

Texture2D<float4> _HeightMap;


//xy 代表Node的二维索引
ConsumeStructuredBuffer<uint2> ConsumeNodeList;
AppendStructuredBuffer<uint2> AppendNodeList;
//xy 代表Node的二维索引 z 代表LOD
AppendStructuredBuffer<uint3> AppendFinalNodeList;
//四叉树遍历完成后，合适的节点存放在这里
StructuredBuffer<uint3> FinalNodeList;

//表示TraverseQuadTree kernel执行的LOD级别
uniform uint PassLOD;
uniform float3 _CameraPositionWS;//相机的位置


//*****裁剪相关变量*******/
uniform float4 _CameraFrustumPlanes[6];//摄像机6个平面 xyz法线方向  w距离
AppendStructuredBuffer<RenderPatch> CulledPatchList;

#if BOUNDS_DEBUG
AppendStructuredBuffer<BoundsDebug> PatchBoundsList;
#endif


//
/**
记录了每个Lod级别的(nodeSize,patchExtent,nodeCount,sectorCountPerNode) 目前0-5 6层

其中:
- nodeSize为Node的边长(米)
- patchExtent等于nodeSize/16
- nodeCount等于WorldSize/nodeSize
- sectorCountPerNode等于2^lod
**/
uniform float4 WorldLodParams[6];

uniform uint NodeIDOffsetOfLOD[6];

float GetNodeSize(uint lod)
{
    return WorldLodParams[lod].x;
}

float GetNodeCount(uint lod)
{
    return WorldLodParams[lod].z;
}

// 获取当前LOD下 单个Patch宽度的一半
float GetHalfPatchSize(uint lod)
{
    return WorldLodParams[lod].y;
}

float2 GetNodePositionWS2(uint2 nodeLoc, uint mip)
{
    float nodeMeterSize = GetNodeSize(mip);
    float nodeCount = GetNodeCount(mip);
    float2 nodePositionWS = ((float2)nodeLoc - (nodeCount - 1) * 0.5) * nodeMeterSize;
    return nodePositionWS;
}

float3 GetNodePositionWS(uint2 nodeLoc, uint lod)
{
    float2 nodePositionWS = GetNodePositionWS2(nodeLoc, lod);
    // float2 minMaxHeight = 1;//MinMaxHeightTexture.mips[lod + 3][nodeLoc].xy;
    // float y = (minMaxHeight.x + minMaxHeight.y) * 0.5 * 1;//_WorldSize.y;
    return float3(nodePositionWS.x, 0, nodePositionWS.y);
}

//决定是否细分Node
/*f = d / (n * c);
d=摄像机到节点中心距离
n=节点边长
c=用户控制系数*/
bool EvaluateNode(uint2 nodeLoc, uint lod)
{
    float3 positionWS = GetNodePositionWS(nodeLoc, lod);
    _CameraPositionWS.y = 0;
    float d = distance(_CameraPositionWS, positionWS);
    float n = GetNodeSize(lod);
    float f = d / (n * NodeEvaluationC);
    //可以四分
    if (f < 1)
    {
        return true;
    }
    return false;
}


// //将三维转换为1维的
// uint GetNodeId(uint3 nodeLoc)
// {
//     return NodeIDOffsetOfLOD[nodeLoc.z] + nodeLoc.y * GetNodeCount(nodeLoc.z) + nodeLoc.x;
// }
//============裁剪相关
//获取Patch的包围盒
Bounds GetPatchBounds(RenderPatch patch)
{
    float halfPachSize = GetHalfPatchSize(patch.lod);
    Bounds bounds;
    float3 boundsMin, boundsMax;
    boundsMin.xz = patch.position - halfPachSize;
    boundsMax.xz = patch.position + halfPachSize;
    boundsMin.y = 0;
    boundsMax.y = 0;

    bounds.minPosition = boundsMin;
    bounds.maxPosition = boundsMax;
    return bounds;
}

//测试是否在平面的外侧
bool IsOutSidePlane(float4 plane, float3 position)
{
    return dot(plane.xyz, position) + plane.w < 0;
}

bool IsAABBOutSidePlane(float4 plane, float3 boundsMin, float3 boundsMax)
{
    return IsOutSidePlane(plane, boundsMin) &&
    IsOutSidePlane(plane, boundsMax) &&
    IsOutSidePlane(plane, float3(boundsMin.x, boundsMin.y, boundsMax.z)) &&
    IsOutSidePlane(plane, float3(boundsMin.x, boundsMax.y, boundsMin.z)) &&
    IsOutSidePlane(plane, float3(boundsMin.x, boundsMax.y, boundsMax.z)) &&
    IsOutSidePlane(plane, float3(boundsMax.x, boundsMin.y, boundsMax.z)) &&
    IsOutSidePlane(plane, float3(boundsMax.x, boundsMax.y, boundsMin.z)) &&
    IsOutSidePlane(plane, float3(boundsMax.x, boundsMin.y, boundsMin.z));
}

bool IsBoundsOutSidePlane(float4 plane, Bounds bounds)
{
    return IsAABBOutSidePlane(plane, bounds.minPosition, bounds.maxPosition);
}

//视锥裁剪
bool FrustumCull(float4 planes[6], Bounds bounds)
{
    return IsBoundsOutSidePlane(planes[0], bounds) ||
    IsBoundsOutSidePlane(planes[1], bounds) ||
    IsBoundsOutSidePlane(planes[2], bounds) ||
    IsBoundsOutSidePlane(planes[3], bounds) ||
    IsBoundsOutSidePlane(planes[4], bounds) ||
    IsBoundsOutSidePlane(planes[5], bounds);
}

bool Cull(Bounds bounds)
{
    //使用视锥裁剪
    return FrustumCull(_CameraFrustumPlanes, bounds);
}
//------------


//遍历四叉树，进行节点评价，生成AppendFinalNodeList和NodeDescriptors
[numthreads(1, 1, 1)]
void TraverseQuadTree(uint3 id: SV_DispatchThreadID)
{
    uint2 nodeLoc = ConsumeNodeList.Consume();
    if (PassLOD > 0 && EvaluateNode(nodeLoc, PassLOD))
    {
        //四分
        AppendNodeList.Append(nodeLoc * 2);
        AppendNodeList.Append(nodeLoc * 2 + uint2(1, 0));
        AppendNodeList.Append(nodeLoc * 2 + uint2(0, 1));
        AppendNodeList.Append(nodeLoc * 2 + uint2(1, 1));
    }
    else
    {
        //不需要分化 全部加入到FinalNode
        AppendFinalNodeList.Append(uint3(nodeLoc, PassLOD));
    }
}

RenderPatch CreatePatch(uint3 nodeLoc, uint2 patchOffset)
{
    uint lod = nodeLoc.z;
    //当前LOD下的Node大小
    float nodeMeterSize = GetNodeSize(lod);
    //当前LOD下的Patch大小 一排是8个
    float patchMeterSize = nodeMeterSize / PATCH_COUNT_PER_NODE;
    //得到当前Node的坐标
    float2 nodePositionWS = GetNodePositionWS2(nodeLoc.xy, lod);

    // uint2 patchLoc = nodeLoc.xy * PATCH_COUNT_PER_NODE + patchOffset;
    //经测试，当min和max相差较小时，RG32似乎还是存在精度问题
    // float2 minMaxHeight = 1;//MinMaxHeightTexture.mips[lod][patchLoc].rg * _WorldSize.y + float2(-_BoundsHeightRedundance, _BoundsHeightRedundance);
    RenderPatch patch;
    patch.lod = lod;
    //局部坐标+node世界坐标
    patch.position = nodePositionWS + (patchOffset - (PATCH_COUNT_PER_NODE - 1) * 0.5) * patchMeterSize;
    // patch.minMaxHeight = minMaxHeight;
    // patch.lodTrans = 0;
    return patch;
}


// 8,8 的原因是 一个Node由8*8个Patch组成
[numthreads(8, 8, 1)]
void BuildPatches(uint3 id: SV_DispatchThreadID, uint3 groupId: SV_GroupID, uint3 groupThreadId: SV_GroupThreadID)
{
    uint3 nodeLoc = FinalNodeList[groupId.x];
    uint2 patchOffset = groupThreadId.xy;
    //生成Patch
    RenderPatch patch = CreatePatch(nodeLoc, patchOffset);
    CulledPatchList.Append(patch);

    //裁剪
    Bounds bounds = GetPatchBounds(patch);
    if (Cull(bounds))
    {
        return;
    }

    //构建每个Patch的包围盒 由两个V3坐标组成
    #if BOUNDS_DEBUG
    #endif
}